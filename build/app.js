(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var frameCounter;

frameCounter = function(size) {
  return new PointText({
    point: size,
    justification: 'right',
    fontSize: 8,
    fillColor: 'black',
    onFrame: function(event) {
      return this.content = event.count;
    }
  });
};

module.exports = {
  frameCounter: frameCounter
};

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/* level model values & functions: */
var model;

model = function() {
  var dirs, steppify;
  this.state = new function() {
    return {
      level: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      dimensions: {
        x: 5,
        y: 5
      },
      position: void 0,
      get: function(input) {
        return this.level[this.idx(input)];
      },
      idx: function(input) {
        return this.dimensions.x * input.y + input.x;
      },
      is_available: function(direction) {
        var np;
        np = this.step(direction);
        if (np.x < 0 || np.x >= this.dimensions.x) {
          return false;
        }
        if (np.y < 0 || np.y >= this.dimensions.y) {
          return false;
        }
        return this.level[this.idx(np)] === 1;
      },
      step: function(direction) {
        return {
          x: this.position.x + direction.x,
          y: this.position.y + direction.y
        };
      },
      print: function() {
        var j, k, ref, ref1, row, x, y;
        for (y = j = 0, ref = this.dimensions.y; 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {
          row = "";
          for (x = k = 0, ref1 = this.dimensions.x; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
            row += this.level[this.idx({
              x: x,
              y: y
            })] + " ";
          }
          console.log(row);
        }
        console.log("position", this.position);
      }
    };
  };
  dirs = [
    {
      x: -1,
      y: 0
    }, {
      x: 0,
      y: -1
    }, {
      x: 1,
      y: 0
    }, {
      x: 0,
      y: 1
    }
  ];
  this.set_position = function(tilexy) {
    if ((this.state.get(tilexy)) !== 0) {
      this.state.position = tilexy;
      this.state.level[this.state.idx(this.state.position)] = 0;
      return true;
    }
    return false;
  };
  this.move = function(direction) {
    var np, path;
    path = [];
    while (this.state.is_available(direction)) {
      np = this.state.step(direction);
      this.state.level[this.state.idx(np)] = 0;
      this.state.position = np;
      path.push(np);
    }
    return path;
  };
  steppify = function(i) {
    return i / Math.abs(i);
  };
  this.clicked = function(tilexy) {
    var dx, dy, result;
    if (this.state.position === void 0) {
      if (this.set_position(tilexy)) {
        return [tilexy];
      }
      return [];
    }
    if (tilexy.x === this.state.position.x) {
      dy = steppify(tilexy.y - this.state.position.y);
      result = [this.state.position].concat(dy !== 0 ? this.move({
        x: 0,
        y: dy
      }) : []);
      return result;
    }
    if (tilexy.y === this.state.position.y) {
      dx = steppify(tilexy.x - this.state.position.x);
      result = [this.state.position].concat(dx !== 0 ? this.move({
        x: dx,
        y: 0
      }) : []);
      return result;
    }
    return [];
  };
  this.checkwin = function() {
    return 0 === state.level.reduce((function(pv, cv) {
      return pv + cv;
    }), 0);
  };
  return this;
};

module.exports = {
  model: model
};

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var colorCrossfade, tile, tileAnimator, view;

tile = function(x, y, w, h, bus, taken) {
  var result;
  result = new Path.Rectangle({
    info: {
      x: x,
      y: y
    },
    taken: taken,
    bus: bus,
    topLeft: [0, 0],
    bottomRight: [w, h],
    radius: ((w + h) * 0.5) * 0.125,
    strokeColor: 'black',
    strokeWidth: 2,
    fillColor: taken === 0 ? {
      gradient: {
        stops: ['yellow', 'red', 'red'],
        radial: true
      },
      origin: [0, 0],
      destination: [w, h]
    } : {
      gradient: {
        stops: ['white', 'grey', 'grey'],
        radial: true
      },
      origin: [0, 0],
      destination: [w, h]
    },
    onMouseDown: function(event) {
      return bus.signal(this);
    }
  });
  result.translate([x * w, y * h]);
  return result;
};

colorCrossfade = function(string1, string2) {
  var hsv;
  hsv = ([string1, string2].map(function(i) {
    return new Color(i);
  })).map(function(c) {
    return [c.hue, c.saturation, c.brightness];
  });
  return hsv.concat([
    hsv[1].map(function(num, idx) {
      return num - hsv[0][idx];
    })
  ]);
};

tileAnimator = function() {
  var data, result;
  data = colorCrossfade('#2EFB47', '#0BABDF');
  result = new Path({
    queue: [],
    add: function(tile, delay) {
      var duration, time;
      if (delay == null) {
        delay = 0;
      }
      time = new Date().getTime() + delay;
      duration = 350;
      this.queue.push({
        start: time,
        duration: duration,
        end: time + duration,
        object: tile,
        color_start: data[0],
        color_end: data[1],
        color_change: data[2]
      });
    },
    onFrame: function(event) {
      var current, each, idx, item, j, k, l, len, len1, len2, r, ref, ref1, removals, t;
      console.log("tileAnimator onFrame");
      current = new Date().getTime();
      removals = [];
      ref = this.queue;
      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        item = ref[idx];
        if (current >= item.end) {
          item.object.fillColor = {
            hue: item.color_end[0],
            saturation: item.color_end[1],
            brightness: item.color_end[2]
          };
          removals.push(idx);
        }
      }
      for (k = 0, len1 = removals.length; k < len1; k++) {
        r = removals[k];
        this.queue.splice(r, 1);
      }
      ref1 = this.queue.filter(function(i) {
        return current >= i.start;
      });
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        each = ref1[l];
        t = (current - each.start) / each.duration;
        result = [0, 1, 2].map(function(i) {
          return t * each.color_change[i] + each.color_start[i];
        });
        each.object.fillColor = {
          hue: result[0],
          saturation: result[1],
          brightness: result[2]
        };
      }
    }
  });
  return result;
};

view = function(model, center) {
  var h, j, k, ref, ref1, t, w, x, y;
  this.animator = new tileAnimator();
  this.model = model;
  t = [];
  for (y = j = 0, ref = model.state.dimensions.y; 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {
    for (x = k = 0, ref1 = model.state.dimensions.x; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
      t.push(new tile(x, y, 60, 60, this, model.state.get({
        x: x,
        y: y
      })));
    }
  }
  this.tiles = new Group(t);
  w = 60 * model.state.dimensions.x;
  h = 60 * model.state.dimensions.y;
  this.tiles.translate([center.x - (w * 0.5), center.y - (h * 0.5)]);
  this.signal = function(tile) {
    var idx, l, len, results, step, steps;
    steps = this.model.clicked(tile.info);
    results = [];
    for (idx = l = 0, len = steps.length; l < len; idx = ++l) {
      step = steps[idx];
      results.push(this.animator.add(this.tiles.children[this.model.state.idx(step)], 70 * idx));
    }
    return results;
  };
  return this;
};

module.exports = {
  tile: tile,
  view: view
};

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var level, main, tc, titleAnimator, utils, viewcontroller;

utils = require('./display.js');

level = require('./levelModel.js');

viewcontroller = require('./levelViewController.js');

tc = require('./titleCard.js');

main = function() {
  var test;
  this.current = new level.model();
  test = new viewcontroller.view(this.current, view.center);
  this.animator = test.animator;
  return this;
};

titleAnimator = function() {
  this.result = new Path({
    next: 0,
    cards: ['one', 'two', '3', 'four', 'five'],
    obj: null,
    go: function() {
      this.obj = new tc.titleCard(view.size, this.cards[this.next]);
      return this.next += 1;
    },
    onFrame: function(event) {
      var diff;
      console.log('title animator onFrame');
      if (this.obj !== null) {
        diff = new Date().getTime() - this.obj.started;
        if (diff < 2000) {

        } else {
          this.obj.remove();
          return this.obj = null;
        }
      }
    }
  });
  return this.result;
};

paper.install(window);

window.onload = function() {
  var app, fc, testing;
  paper.setup('puzzls');
  fc = utils.frameCounter(view.size);
  app = new main();
  testing = new titleAnimator();
  return testing.go();
};

},{"./display.js":1,"./levelModel.js":2,"./levelViewController.js":3,"./titleCard.js":5}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var titleCard;

titleCard = function(size, cardtext) {
  var rect, text;
  rect = new Path.Rectangle({
    topLeft: [0, 0],
    bottomRight: size,
    fillColor: 'white'
  });
  text = new PointText({
    point: [size.width * .5, size.height * .5],
    content: cardtext,
    justification: 'center',
    fontSize: 33,
    fillColor: 'black'
  });
  this.handle = new Group([rect, text]);
  this.handle.started = new Date().getTime();
  return this.handle;
};

module.exports = {
  titleCard: titleCard
};

},{}]},{},[4]);
