(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var frameCounter;

frameCounter = function(size) {
  return new PointText({
    point: size,
    justification: 'right',
    fontSize: 8,
    fillColor: 'black',
    onFrame: function(event) {
      return this.content = event.count;
    }
  });
};

module.exports = {
  frameCounter: frameCounter
};

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/* level model values & functions: */
var model;

model = function(controller) {
  var dirs, steppify;
  this.controller = controller;
  this.state = new function() {
    return {
      get: function(input) {
        return this.level[this.idx(input)];
      },
      idx: function(input) {
        return this.dimensions.x * input.y + input.x;
      },
      is_available: function(direction) {
        var np;
        np = this.step(direction);
        if (np.x < 0 || np.x >= this.dimensions.x) {
          return false;
        }
        if (np.y < 0 || np.y >= this.dimensions.y) {
          return false;
        }
        return this.level[this.idx(np)] !== 0;
      },
      step: function(direction) {
        return {
          x: this.position.x + direction.x,
          y: this.position.y + direction.y
        };
      },
      print: function() {
        var j, k, ref, ref1, row, x, y;
        for (y = j = 0, ref = this.dimensions.y; 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {
          row = "";
          for (x = k = 0, ref1 = this.dimensions.x; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
            row += this.level[this.idx({
              x: x,
              y: y
            })] + " ";
          }
          console.log(row);
        }
        console.log("position", this.position);
      }
    };
  };
  dirs = [
    {
      x: -1,
      y: 0
    }, {
      x: 0,
      y: -1
    }, {
      x: 1,
      y: 0
    }, {
      x: 0,
      y: 1
    }
  ];
  this["new"] = function(level) {
    var i;
    this.state.level = [
      (function() {
        var j, len, ref, results;
        ref = level.data;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(i);
        }
        return results;
      })()
    ][0];
    this.state.dimensions = level.dimensions;
    this.state.position = void 0;
  };
  this.set_position = function(tilexy) {
    var tinfo;
    if ((this.state.get(tilexy)) === 1) {
      this.state.position = tilexy;
      tinfo = this.state.level[this.state.idx(this.state.position)];
      this.state.level[this.state.idx(this.state.position)] = 0;
      return true;
    }
    return false;
  };
  this.move = function(direction) {
    var idx, np, path;
    path = [];
    while (this.state.is_available(direction)) {
      np = this.state.step(direction);
      idx = this.state.idx(np);
      if (this.state.level[idx] === 2) {
        direction = {
          x: 0,
          y: -1
        };
      }
      if (this.state.level[idx] === 3) {
        direction = {
          x: 1,
          y: 0
        };
      }
      if (this.state.level[idx] === 4) {
        direction = {
          x: 0,
          y: 1
        };
      }
      if (this.state.level[idx] === 5) {
        direction = {
          x: -1,
          y: 0
        };
      }
      this.state.level[this.state.idx(np)] = 0;
      this.state.position = np;
      path.push(np);
    }
    if (this.checkwin()) {
      controller.advance();
      return [];
    } else if (this.checkstuck()) {
      controller.reset();
      return [];
    }
    return path;
  };
  steppify = function(i) {
    return i / Math.abs(i);
  };
  this.clicked = function(tilexy) {
    var dx, dy, result;
    if (this.state.position === void 0) {
      if (this.set_position(tilexy)) {
        return [tilexy];
      }
      return [];
    }
    if (tilexy.x === this.state.position.x) {
      dy = steppify(tilexy.y - this.state.position.y);
      result = [this.state.position].concat(dy !== 0 ? this.move({
        x: 0,
        y: dy
      }) : []);
      return result;
    }
    if (tilexy.y === this.state.position.y) {
      dx = steppify(tilexy.x - this.state.position.x);
      result = [this.state.position].concat(dx !== 0 ? this.move({
        x: dx,
        y: 0
      }) : []);
      return result;
    }
    return [];
  };
  this.checkwin = function() {
    return 0 === this.state.level.reduce((function(pv, cv) {
      return pv + cv;
    }), 0);
  };
  this.checkstuck = function() {
    var d, result;
    result = [
      (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = dirs.length; j < len; j++) {
          d = dirs[j];
          results.push(this.state.is_available(d));
        }
        return results;
      }).call(this)
    ][0].filter(function(i) {
      return i === true;
    });
    return result.length === 0;
  };
  return this;
};

module.exports = {
  model: model
};

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var colorCrossfade, colorFree, colorTaken, tile, tileAnimator, view;

colorFree = '#F7F8B0';

colorTaken = '#FF4941';

tile = function(x, y, w, h, bus, taken) {
  var makeTriangle, result;
  result = [
    new Path.Rectangle({
      info: {
        x: x,
        y: y
      },
      taken: taken,
      bus: bus,
      topLeft: [0, 0],
      bottomRight: [w, h],
      radius: ((w + h) * 0.5) * 0.125,
      strokeColor: 'black',
      strokeWidth: 2,
      fillColor: taken === 0 ? colorTaken : colorFree,
      onMouseDown: function(event) {
        return bus.signal(this);
      },
      reset: function() {
        return this.fillColor = taken === 0 ? colorTaken : colorFree;
      }
    })
  ];
  makeTriangle = function(angle) {
    var toAdd;
    toAdd = new Path.RegularPolygon(new Point(w * 0.5, h * 0.5), 3, 10);
    toAdd.fillColor = toAdd.strokeColor = 'black';
    toAdd.rotate(angle);
    toAdd.onMouseDown = function(event) {
      return this.parent.children[0].onMouseDown(event);
    };
    return toAdd;
  };
  if (taken >= 2 && taken <= 5) {
    result.push(makeTriangle(90 * (taken - 2)));
  }
  result = new Group(result);
  result.translate([x * w, y * h]);
  return result;
};

colorCrossfade = function(string1, string2) {
  var hsv;
  hsv = ([string1, string2].map(function(i) {
    return new Color(i);
  })).map(function(c) {
    return [c.hue, c.saturation, c.brightness];
  });
  return hsv.concat([
    hsv[1].map(function(num, idx) {
      return num - hsv[0][idx];
    })
  ]);
};

tileAnimator = function() {
  var data, result;
  data = colorCrossfade('#2EFB47', '#0BABDF');
  result = new Path({
    queue: [],
    add: function(tile, delay) {
      var duration, time;
      if (delay == null) {
        delay = 0;
      }
      time = new Date().getTime() + delay;
      duration = 350;
      this.queue.push({
        start: time,
        duration: duration,
        end: time + duration,
        object: tile,
        color_start: data[0],
        color_end: data[1],
        color_change: data[2]
      });
    },
    reset: function() {
      return this.queue.splice(0, this.queue.length - 1);
    },
    onFrame: function(event) {
      var current, each, idx, item, j, k, l, len, len1, len2, r, ref, ref1, removals, t;
      current = new Date().getTime();
      removals = [];
      ref = this.queue;
      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        item = ref[idx];
        if (current >= item.end) {
          item.object.fillColor = {
            hue: item.color_end[0],
            saturation: item.color_end[1],
            brightness: item.color_end[2]
          };
          removals.push(idx);
        }
      }
      for (k = 0, len1 = removals.length; k < len1; k++) {
        r = removals[k];
        this.queue.splice(r, 1);
      }
      ref1 = this.queue.filter(function(i) {
        return current >= i.start;
      });
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        each = ref1[l];
        t = (current - each.start) / each.duration;
        result = [0, 1, 2].map(function(i) {
          return t * each.color_change[i] + each.color_start[i];
        });
        each.object.fillColor = {
          hue: result[0],
          saturation: result[1],
          brightness: result[2]
        };
      }
    }
  });
  return result;
};

view = function(model, center) {
  var h, j, k, ref, ref1, t, w, x, y;
  this.animator = new tileAnimator();
  this.model = model;
  t = [];
  for (y = j = 0, ref = model.state.dimensions.y; 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {
    for (x = k = 0, ref1 = model.state.dimensions.x; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
      t.push(new tile(x, y, 60, 60, this, model.state.get({
        x: x,
        y: y
      })));
    }
  }
  this.tiles = new Group(t);
  w = 60 * model.state.dimensions.x;
  h = 60 * model.state.dimensions.y;
  this.tiles.translate([center.x - (w * 0.5), center.y - (h * 0.5)]);
  this.signal = function(tile) {
    var idx, l, len, results, step, steps;
    steps = this.model.clicked(tile.info);
    results = [];
    for (idx = l = 0, len = steps.length; l < len; idx = ++l) {
      step = steps[idx];
      results.push(this.animator.add(this.tiles.children[this.model.state.idx(step)], 70 * idx));
    }
    return results;
  };
  return this;
};

module.exports = {
  tile: tile,
  view: view
};

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var basics, dvaVariations, intermediate, levels, triangles;

triangles = [
  {
    data: [1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "tri.1"
  }, {
    data: [1, 1, 4, 1, 1, 1, 0, 4, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "tri.2"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "tri.3"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 5, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 3, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "tri.4"
  }
];

basics = [
  {
    data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "1"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "2"
  }, {
    data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "3"
  }, {
    data: [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "3.1"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "3.2"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "3.4"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "3.5"
  }
];

dvaVariations = [
  {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.0"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.1"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.2"
  }, {
    data: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.3 (cut)"
  }, {
    data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.4 (cut)"
  }, {
    data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.5 (cut)"
  }, {
    data: [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.6 (cut)"
  }, {
    data: [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.7 (cut)"
  }, {
    data: [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.8 (cut)"
  }, {
    data: [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.9 (cut)"
  }, {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "dva.10 (maybe)"
  }
];

intermediate = [
  {
    data: [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
    dimensions: {
      x: 5,
      y: 5
    },
    name: "4"
  }
];

levels = ((basics.concat(dvaVariations)).concat(intermediate)).concat(triangles);

module.exports = {
  levels: levels
};

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var level, levels, tc, titleAnimator, utils, viewcontroller;

utils = require('./display.js');

level = require('./levelModel.js');

viewcontroller = require('./levelViewController.js');

tc = require('./titleCard.js');

levels = (require('./levels.js')).levels;

titleAnimator = function() {
  this.result = new Path({
    obj: [],
    go: function(name) {
      return this.obj.push(new tc.titleCard(view.size, name));
    },
    onFrame: function(event) {
      var diff, i, len, o, ref;
      ref = this.obj;
      for (i = 0, len = ref.length; i < len; i++) {
        o = ref[i];
        diff = new Date().getTime() - o.started;
        if (diff < 2000) {
          return;
        } else {
          o.remove();
          this.obj = [];
        }
      }
    }
  });
  return this.result;
};

paper.install(window);

window.onload = function() {
  var fc;
  paper.setup('puzzls');
  fc = utils.frameCounter(view.size);
  this.model = new level.model(this);
  this.current = 0;
  this.model["new"](levels[0]);
  this.vc = new viewcontroller.view(this.model, view.center);
  this.ta = new titleAnimator();
  this.ta.go(levels[this.current].name);
  this.advance = function() {
    this.current = (this.current + 1) % levels.length;
    this.model["new"](levels[this.current]);
    this.vc.tiles.remove();
    this.vc = new viewcontroller.view(this.model, view.center);
    return this.ta.go(levels[this.current].name);
  };
  return this.reset = function() {
    this.model["new"](levels[this.current]);
    this.vc.tiles.remove();
    this.vc = new viewcontroller.view(this.model, view.center);
  };
};

},{"./display.js":1,"./levelModel.js":2,"./levelViewController.js":3,"./levels.js":4,"./titleCard.js":6}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var titleCard;

titleCard = function(size, cardtext) {
  var rect, text;
  rect = new Path.Rectangle({
    topLeft: [0, 0],
    bottomRight: size,
    fillColor: 'white'
  });
  text = new PointText({
    point: [size.width * .5, size.height * .5],
    content: cardtext,
    justification: 'center',
    fontSize: 33,
    fillColor: 'black'
  });
  this.handle = new Group([rect, text]);
  this.handle.started = new Date().getTime();
  return this.handle;
};

module.exports = {
  titleCard: titleCard
};

},{}]},{},[5]);
